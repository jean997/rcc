---
title: "Biomarker cutpoint experiments"
author: "Jean Morrison"
date: "December 24, 2016"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Biomarker Experiment

Lets say we are interested in the treatment effect of a drug but I think that some additional variable $x$ can help guide treatment decisions. Maybe I only really expect to see a treatment effect for large values of $x$. Lets say the outcome I care about is a continuous measurement $y$.


Here is a simple example where population values of $x$ are uniformly distributed between 0 and 1 and $E[y | trt=0] = 0.5*x$ and $E[y| trt = 1] = x$. 
```{r}
mean_outcome <- function(x, trt){
  if(x < 0.5) return(0)
  return((x-0.5)*trt)
}
mo <- function(xx, trt){
  unlist(lapply(xx, FUN=function(xxx){mean_outcome(xxx, trt)}))
}
curve(mo(x, trt=0), ylim=c(0, 1), ylab="treatment effect")
curve(mo(x, trt=1), add=TRUE, col="red")
legend("topleft", legend=c("trt=0", "trt=1"), lty=c(1, 1), col=c("black", "red"))
```

Generate some data

```{r}
set.seed(1e7)
dat <- data.frame("trt"=rep(c(0, 1), each=100), "x"=runif(n=200))
dat$mu <- apply(dat, MARGIN=1, FUN=function(z){mean_outcome(z[2],z[1])})
dat$y <- rnorm(n=200, mean=dat$mu, sd=0.5)
plot(dat$x, dat$y, col=dat$trt + 1)
```

For any cutpoint $\tilde{x}$, the true average treatment effect for patients with $x > \tilde{x}$ is
$$\beta(\tilde{x}) = \frac{\int_{\tilde{x}}^{1} (\mu_{1}(x)-\mu_0(x)) p(x)dx}{\int_{\tilde{x}}^1 p(x)dx} $$
Plugging in the values in this example 
%($p(x)=1$, $\mu_1(x)=x$ and $\mu_0(x)=0.5x$) is 
%$$\beta(\tilde{x}) = \frac{\frac{1}{4}-\frac{\tilde{x}^2}{4}}{1-\tilde{x}} $$
%$$\beta(\tilde{x}) = \frac{1-max(0.5, \tilde{x})}{1-\tilde{x}} $$

$$\beta(\tilde{x}) = \frac{\frac{1}{8}-\frac{max(0, (\tilde{x}-0.5)^2)}{8}}{1-\tilde{x}} $$

```{r}
cutpoints <- sort(dat$x)[-200][1:180]

stats <- lapply(cutpoints, FUN=function(xx){
  f <- lm(y~trt, data=dat[dat$x >= xx,])
  summary(f)$coefficients[2, 1:3]
})
stats <- data.frame(matrix(unlist(stats), byrow=TRUE, ncol=3))
names(stats) <- c("beta", "se", "tstat")
#stats$truth <- (1/4 - (cutpoints^2)/4)/(1-cutpoints)
#stats$truth <- (1-pmax(0.5, cutpoints))/(1-cutpoints)
stats$truth <- ((1/8)-pmax(0, ((cutpoints-0.5)^2)/8))/(1-cutpoints)
plot(cutpoints, stats$tstat)
plot(stats$beta, stats$truth)
abline(0, 1)
```

Lets make confidence intervals for the average treatment effect for individuals with $x$ values above the cutpoint.

Naive confidence intervals:
```{r}
ci.naive <- cbind(stats$beta-stats$se*qnorm(0.975), stats$beta + stats$se*qnorm(0.975))
sum(ci.naive[,1] <= stats$truth & stats$truth <= ci.naive[,2])/190
plot(cutpoints, ci.naive[,1], pch=16, cex=0.5, 
     ylim=range(cbind(ci.naive, stats$truth)), xlab="Cutpoint", ylab="Treatment Effect")
points(cutpoints, ci.naive[,2], pch=16, cex=0.5)
points(cutpoints, stats$truth, col="red", cex=0.5, pch=16)
legend("topleft", legend=c("CI bound", "truth"), pch=rep(16, 2), col=c("black", "red"), cex=0.5)
```

Bootstrap confidence intervals (non-parametric)

```{r, cache=TRUE}
n.rep <- 500
n <- dim(dat)[1]
B <- replicate(n=n.rep, expr={
  S <- sample(1:n, size=n, replace=TRUE)
  dat.new <- dat[S, ]
  stats.new <- lapply(cutpoints, FUN=function(xx){
    if(sum(dat$x >=xx) <= 2) return(rep(NA, 3))
    f <- lm(y~trt, data=dat.new[dat.new$x >= xx,])
    coef <- summary(f)$coefficients
    if(nrow(coef)==1) return(rep(NA, 3))
    return(coef[2, 1:3])
  })
  stats.new <- data.frame(matrix(unlist(stats.new), byrow=TRUE, ncol=3))
  names(stats.new) <- c("beta", "se", "tstat")
  k <- order(abs(stats.new$tstat))
  sign(stats.new$beta[k])*(stats.new$beta[k]-stats$truth[k])
})
qs <- apply(B, MARGIN=1, FUN=function(x){quantile(x, probs=c(0.05, 0.95), na.rm=TRUE)})
j <- order(abs(stats$tstat))
my.ci <- cbind(stats$beta[j]-qs[2,], stats$beta[j]-qs[1,])
which.neg <- which(stats$beta[j] < 0)
my.ci[ which.neg , ] <- cbind(stats$beta[j][which.neg] + qs[1,which.neg],
                                stats$beta[j][which.neg]+qs[2,which.neg])
  #Re order
k <- match(stats$beta, stats$beta[j])
my.ci <- my.ci[k,]
```

```{r}
sum( my.ci[,1] <= stats$truth & stats$truth <= my.ci[,2])/190
plot(cutpoints, my.ci[,1], pch=16, cex=0.5, ylim=range(cbind(my.ci, stats$truth)), 
      xlab="Cutpoint", ylab="Treatment Effect")
points(cutpoints, my.ci[,2], pch=16, cex=0.5)
points(cutpoints, stats$truth, col="red", cex=0.5, pch=16)
legend("topleft", legend=c("CI bound", "truth"), pch=rep(16, 2), col=c("black", "red"), cex=0.5)
```

It looks like the parametric bootstrap is conservative in this case while it looks like ASH gives under-coverage as a result of the correlation between tests.

```{r}
library(ashr)
ash.res <- ash(betahat = stats$beta, sebetahat = stats$se, mixcompdist = "normal")
ci.ash <- ashci(ash.res, level=0.9, betaindex = 1:180 )
sum(ci.ash[,1] <= stats$truth & stats$truth <= ci.ash[,2])/190
plot(cutpoints, ci.ash[,1], pch=16, cex=0.5, ylim=range(cbind(ci.ash, stats$truth)), 
     xlab="Cutpoint", ylab="Treatment Effect")
points(cutpoints,ci.ash[,2], pch=16, cex=0.5)
points(cutpoints,stats$truth, col="red", cex=0.5, pch=16)
legend("topleft", legend=c("CI bound", "truth"), pch=rep(16, 2), col=c("black", "red"), cex=0.5)
```

